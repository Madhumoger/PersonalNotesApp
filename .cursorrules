# Personal Notes App - Cursor Rules

## Project Overview
This is a Kotlin Multiplatform (KMP) project using Compose Multiplatform for shared UI across Android and iOS platforms.

## Project Structure
- `composeApp/src/commonMain/` - Shared Kotlin code and Compose UI
- `composeApp/src/androidMain/` - Android-specific implementations
- `composeApp/src/iosMain/` - iOS-specific implementations
- `iosApp/` - iOS native app wrapper

## Code Style & Conventions

### Kotlin Style
- Use 4 spaces for indentation
- Follow Kotlin coding conventions
- Use meaningful variable and function names
- Prefer immutability (val over var)
- Use data classes for models
- Leverage Kotlin null safety

### Naming Conventions
- Classes: PascalCase (e.g., `NoteRepository`)
- Functions: camelCase (e.g., `saveNote()`)
- Constants: UPPER_SNAKE_CASE (e.g., `MAX_NOTE_LENGTH`)
- Composables: PascalCase (e.g., `NoteListScreen()`)

## Architecture Guidelines
MVVM (MODULE- VIEW -VIEWMODEL)

### Compose Best Practices
- Keep Composables small and focused
- Use remember and rememberSaveable appropriately
- Prefer stateless Composables when possible
- Use state hoisting for better testability
- Follow Material Design 3 guidelines
- Use proper key() for lists

### Multiplatform Patterns
- Place shared logic in commonMain
- Use expect/actual for platform-specific implementations
- Keep platform-specific code minimal
- Use appropriate KMP libraries (kotlinx.coroutines, kotlinx.serialization, etc.)

### State Management
- Use StateFlow for observable state
- Implement ViewModel pattern where appropriate
- Keep business logic separate from UI

## File Organization
- Group related files by feature, not by type
- Keep platform-specific files in their respective sourcesets
- Use clear package naming (e.g., `com.personal.notes.feature.noteList`)

## Dependencies
- Prefer stable, well-maintained libraries
- Use version catalogs (libs.versions.toml) for dependency management
- Keep dependencies up-to-date

## Testing
- Write unit tests in commonTest when possible
- Test platform-specific code in respective test sourcesets
- Aim for high test coverage on business logic

## Platform Considerations

### Android
- Target modern Android versions (API 24+)
- Use Material 3 components
- Follow Android best practices for lifecycle management

### iOS
- Ensure smooth integration with SwiftUI wrapper
- Handle iOS-specific UI patterns appropriately
- Test on both iOS Simulator and devices

## Comments & Documentation
- Use KDoc for public APIs
- Add inline comments only when code isn't self-explanatory
- Document complex algorithms or business logic
- Keep comments up-to-date with code changes

## General Preferences
- Favor readability over cleverness
- Use Kotlin idioms and features effectively
- Handle errors gracefully with proper error messages
- Log appropriately for debugging
- Avoid hardcoded strings - use string resources

## When Making Changes
- Ensure changes work on both platforms
- Run tests after modifications
- Check for compilation errors in all sourcesets
- Follow existing patterns in the codebase
- Consider backwards compatibility


### Clean Architecture Layers
- **Presentation (UI)**: Compose Multiplatform UI components, ViewModels
- **Domain**: Use cases, business logic, repository interfaces
- **Data**: Repository implementations, data sources, DTOs

### Module Structure
PersnolaNotesApp/
├── composeApp/           # Main application module
├── core-database/        # Database layer (SQLDelight) if any
├── core-network/         # Network layer (Ktor) if any
├── common/              # Shared utilities
│   ├── data/
│   ├── domain/
│   └── ui/
└── features/            # Feature modules
    if there are multiple feature seperate each  with
    # data/        # Data layer
    #domain/       # Business logic
    #ui/          # Presentation layer

**UI & Navigation:**
- **Jetpack Compose**: Material3, Foundation, Icons
- **Navigation Compose**: `2.7.0-alpha07`
- **Lifecycle**: `2.9.4` - ViewModel & Runtime Compose

**Networking:**
- **Ktor**: `3.0.3` - HTTP client
  - Core, Logging, Content Negotiation
  - Platform-specific engines (OkHttp, Darwin, CIO)
- **Kotlinx Serialization**: `1.8.0` - JSON serialization
- **Coil**: `3.1.0` - Image loading

**Database:**
- **SQLDelight**: `2.0.1` - Type-safe SQL
- **Coroutines Extensions** for reactive queries

**Dependency Injection:**
- **Koin**: `4.0.3` - Core, Compose, ViewModel integration

**Concurrency:**
- **Kotlinx Coroutines**: `1.10.2`

**Target Platforms:**
- **Android**: API 24-36
- **iOS**: ARM64 & Simulator

follow a **reverse domain naming** pattern:

**Base Package**: `com.personal.notes.`

**Structure Pattern:**
```
com.personal.notes..{module}.{layer}.{component}

**Layer Organization:**
- **`di/`** - Dependency injection modules
- **`model/`** - Data models and DTOs
- **`repository/`** - Repository implementations
- **`useCases/`** - Business logic use cases
- **`apiService/`** - Network service interfaces
- **`client/`** - HTTP client configurations


### Code Structure Guidelines

#### Use Cases
#### Repository Pattern
#### DI Modules
#### ViewModels
## Build Configuration

### Gradle Files
- Use `libs.versions.toml` for version catalog
- Apply plugins via version catalog aliases
- Separate build configs for each module
- Use `projects.{module}` for inter-module dependencies

## Performance Considerations
- Use `factory` for lightweight objects, `single` for heavy ones
- Implement proper caching strategies
- Use Flow for reactive data streams
- Optimize Compose recompositions
- Use appropriate image loading strategies with Coil

## Security & Best Practices
- Store sensitive data securely
- Use proper network security (HTTPS, certificate pinning)
- Validate all inputs
- Handle edge cases gracefully
- Follow platform-specific guidelines

## Documentation
README.md file including:

o Project structure
o Architecture explanation
o List of libraries used
o How HTML clicks and PDF are handled
o Screen recording of app walk-through
TRY TO MAKE AS SIMILAR AS POSSIBLE TO HUMAN WRITTERN
